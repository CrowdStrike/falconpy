"""DHS Known Vulnerabilities correlated with CrowdStrike Spotlight.

 _______             __   __ __       __    __
|   _   .-----.-----|  |_|  |__.-----|  |--|  |_
|   1___|  _  |  _  |   _|  |  |  _  |     |   _|
|____   |   __|_____|____|__|__|___  |__|__|____|
|:  1   |__|                   |_____|
|::.. . |
`-------'   DHS Known Vulnerabilities correlator

Creation date: 02.02.22 - ciberesponce@CrowdStrike, jshcodes@CrowdStrike
Modification:  07.20.22 - jshcodes@CrowdStrike, Add closed vulnerability filtering
Modification:  09.13.22 - jshcodes@CrowdStrike, Add hostnames to CSV output / multithreading

Based on the example:
https://github.com/CrowdStrike/falconpy/blob/main/samples/spotlight/find_hosts_by_cve.py

Requires: crowdstrike-falconpy v1.2.0+
          numpy
          pandas
          requests
"""
import sys
from datetime import date
from argparse import ArgumentParser, RawTextHelpFormatter
import concurrent.futures
try:
    import requests
except ImportError as no_requests:
    raise SystemExit("The requests package must be installed in order to use this application.") from no_requests

try:
    import numpy as np
except ImportError as no_numpy:
    raise SystemExit("The numpy package must be installed in order to use this application.") from no_numpy

try:
    import pandas as pd
except ImportError as no_pandas:
    raise SystemExit("The pandas package must be installed in order to use this application.") from no_pandas

try:
    from falconpy import SpotlightVulnerabilities, Hosts, __version__ as FALCONPY_VERSION
except ImportError as no_falconpy:
    raise SystemExit("The crowdstrike-falconpy package must be installed "
                     "in order to use this application.") from no_falconpy

fp_vers = FALCONPY_VERSION.split(".")
if not bool(float(f"{fp_vers[0]}.{fp_vers[1]}") >= 1.2):
    raise SystemExit("This application requires FalconPy version 1.2.0 or greater to be installed.")

def inform(msg: str):
    """Provide informational updates to the user as the program progresses."""
    print("  %-80s" % msg, end="\r", flush=True)  # pylint: disable=C0209


def parse_command_line() -> object:
    """Parse any received inbound command line parameters."""
    inform("Retrieving configuration detail")
    parser = ArgumentParser(
        description=__doc__,
        formatter_class=RawTextHelpFormatter
        )
    parser.add_argument(
        '-k',
        '--client_id',
        help='CrowdStrike Falcon API key ID.',
        required=True
        )
    parser.add_argument(
        '-s',
        '--client_secret',
        help='CrowdStrike Falcon API key secret.',
        required=True
        )
    parser.add_argument(
        '-b',
        '--base_url',
        help='CrowdStrike API region (us1, us2, eu1, usgov1)'
        ' NOT required unless you are using `usgov1`.',
        required=False,
        default="auto"
    )
    parser.add_argument(
        '-c',
        '--closed',
        help='Also include closed and expired vulnerabilities.',
        required=False,
        action="store_false",
        default=True
    )
    parser.add_argument(
        '-v',
        '--no_ssl_verify',
        help='By default, we will validate HTTPS SSL verification when downloading'
        ' DHS Known Exploited Vulnerabilties.\n'
        'However if you are behind a network device that intercepts HTTPS connections, '
        'this could cause an error.\nSet this to false if you know this to be the case.',
        required=False,
        action="store_false",
        default=True
    )

    return parser.parse_args()


def crowdstrike_spotlight_lookup(cves: list, close_filter: bool) -> list:
    """Look up CVE hits for matches within CrowdStrike Spotlight."""
    # force this to be a list
    cfilter = ""
    if close_filter:
        cfilter = "+status:['open','reopen']"
    if not isinstance(cves, list):
        cves = [cves]
    result = falcon.query_vulnerabilities(filter=f"cve.id:{cves}{cfilter}")
    if result["status_code"] >= 400:
        raise SystemExit(result["body"]["errors"][0]["message"])
    return result


def get_unique_host_ids(results_list: list) -> list:
    """Generate a list of unique host ID matches."""
    # first, scrub the list keeping only the host id from each resource result
    new_list = []
    for item in results_list:
        # grab first part of string, which is CrowdStrike host id
        new_list.append(item.partition("_")[0])
    # push into numpy so we can then use its _unique_ function as some machines can have multiple
    #   CPEs impacted by a single CVE
    #   (i.e. Edge and IE; these mappings to application can be done in Spotlight UI Console)
    return np.unique(np.array(new_list)).tolist()


def retrieve_constants(args: object):
    """Consume command line and environment variables and return constant values as specified."""
    today = date.today().strftime("%Y-%m-%d")

    return args.base_url, args.client_id, args.client_secret, today, args.no_ssl_verify, args.closed


def retrieve_cisa_vulnerabilities(today_value: str) -> str:
    """Retrieve the CISA Known Exploited Vulnerabilities file."""
    inform("Retrieving CISA Known Exploited Vulnerabilities")
    # Get DHS CISA file
    cisa_csv_uri = 'https://www.cisa.gov/sites/default/files/csv/known_exploited_vulnerabilities.csv'
    created_file = f"{sys.path[0]}/{today_value}_CisaKnownExploitable.csv"
    if not SSL_VERIFY:
        sslv = False
        cisa_csv_request = requests.get(cisa_csv_uri, verify=sslv, timeout=60)
    else:
        cisa_csv_request = requests.get(cisa_csv_uri, timeout=60)

    if cisa_csv_request.status_code != 200:
        raise SystemExit(
            "".join([
                "ERROR! Unable to download CISA's CSV file.\n",
                f"Check internet or see if site still exists at: {cisa_csv_uri}"
                ])
            )

    with open(created_file, 'wb') as known_exploitable:
        known_exploitable.write(cisa_csv_request.content)

    return created_file


def connect_api(client_id_value: str,
                client_secret_value: str,
                base_url_value: str
                ) -> SpotlightVulnerabilities:
    """Connect to the CrowdStrike Spotlight API."""
    inform("Connecting API")
    return SpotlightVulnerabilities(client_id=client_id_value,
                                    client_secret=client_secret_value,
                                    base_url=base_url_value
                                    )


def do_compare(cve_guid, hide, msg, pos):
    """Process comparisons asynchronously to speed up execution times."""
    spotlight_results = crowdstrike_spotlight_lookup(cve_guid, hide)
    resources_results = spotlight_results['body']['resources']
    resources_list = []
    inform(f"{msg} {cve_guid}    ")
    if len(resources_results) > 0:
        resources_list = get_unique_host_ids(resources_results)
    # Leverages new GetDeviceDetails functionality, requires FalconPy v1.2+
    asset_names = []
    # Batch the hostname lookups in case we get more than 5000 back
    for batch in [resources_list[r:r+5000] for r in range(0, len(resources_list), 5000)]:
        assets = falcon_hosts.get_device_details(ids=batch)
        if assets["status_code"] == 200:
            if "resources" in assets["body"]:
                ret = assets["body"]["resources"]
                if ret:
                    asset_names.extend(
                        [f"{d.get('hostname', 'Unnamed')} ({d['device_id']})" for d in ret]
                        )
    return (pos, asset_names)

def search_for_spotlight_matches(inbound_dataframe, today_value, hide_closed):
    """Search the dataframe for results that have matches within Spotlight."""
    inform_msg = "".join([
        "Comparing DHS Known Exploited Vulns against Spotlight data. ",
        "Please wait, currently checking"
        ])
    inform(inform_msg)
    with concurrent.futures.ThreadPoolExecutor() as executor:
        futures = {
            executor.submit(do_compare, inbound_dataframe.iloc[i]['cveID'], hide_closed, inform_msg, i)
            for i in range(0, len(inbound_dataframe))
        }
        for fut in concurrent.futures.as_completed(futures):
            if fut.result():
                inbound_dataframe.at[fut.result()[0], 'AssetsVulnerable'] = ", ".join(fut.result()[1])
                inbound_dataframe.at[fut.result()[0], 'AssetsVulnerableCount'] = len(fut.result()[1])

    inform("Writing RAW data")
    # todo - filter out all ones 0 as new dataframe
    inbound_dataframe.to_csv(f"{sys.path[0]}/{today_value}_RawDhsCve.csv", sep=",", na_rep="N/A")

    return inbound_dataframe


def parse_cisa_data(parse_file: str) -> object:
    """Parse the CISA Known Exploited Vulnerabilities file and create a new dataframe."""
    inform("Parsing results")
    # Now parse CSV using pandas, GUID is CVE-ID
    new_dataframe = pd.read_csv(parse_file, parse_dates=['dueDate', 'dateAdded'])

    # extend dataframe
    new_dataframe['AssetsVulnerableCount'] = int(0)
    pd.to_numeric(new_dataframe['AssetsVulnerableCount'])
    # force these fields to be dtype objects
    new_dataframe['AssetsVulnerable'] = pd.NaT
    new_dataframe['AssetsVulnerable'] = new_dataframe['AssetsVulnerable'].astype('object').dtypes

    return new_dataframe


def correlate_results(inbound_dataframe, today_value) -> object:
    """Remove uncorrelated results and sort by asset count, writing results to a file."""
    inform("Removing uncorrelated results")
    # remove ones who have no fusion with Spotlight data
    inbound_dataframe = inbound_dataframe[inbound_dataframe.AssetsVulnerableCount != 0]
    inform("Sorting by asset count")
    # sort by Count of Assets Vulnerable per CVE
    top_cves_by_count_df = inbound_dataframe.sort_values(by='AssetsVulnerableCount',
                                                         ascending=False
                                                         )
    top_cves_by_count_df.to_csv(
        f"{sys.path[0]}/{today_value}_TopDhsCves.csv",
        sep=",",
        na_rep="N/A"
        )

    return inbound_dataframe


def prioritize_results(inbound_dataframe, today_value) -> object:
    """Prioritize results by due date and write to a CSV file."""
    inform("Prioritizing")
    # sort by due-date for prioritization to be compliance against DHS
    inbound_dataframe = inbound_dataframe.sort_values(by='dueDate')
    inform("Writing prioritized results--based on DueDate per DHS CISA")
    inbound_dataframe.to_csv(
        f"{sys.path[0]}/{today_value}_MostUrgentUnpatchedDhsCves.csv",
        sep=",",
        na_rep="N/A"
        )

    return inbound_dataframe


def sort_by_severity(inbound_dataframe, today_value) -> object:
    """Sort results by severity and write to a CSV file."""
    inform("Sorting by severity")
    handled = pd.Series(inbound_dataframe['AssetsVulnerable'].explode().unique())
    inform("Writing prioritized results--based on number of unique impacted assets")
    handled.to_csv(f"{sys.path[0]}/{today_value}_MostVulnerableAssetsDhsCves.csv", sep=",", na_rep="N/A")

    return handled


# Retrieve all inbound command line parameters
TODAY = date.today().strftime("%Y-%m-%d")
BASE_URL, CLIENT_ID, CLIENT_SECRET, TODAY, SSL_VERIFY, FILTER_CLOSED = retrieve_constants(
    parse_command_line()
    )

# Connect to the CrowdStrike Spotlight API
falcon = connect_api(CLIENT_ID, CLIENT_SECRET, BASE_URL)
falcon_hosts = Hosts(auth_object=falcon.auth_object)
if falcon.token_status != 201:
    # Unsuccessful API login, exit routine.
    raise SystemExit("Unable to access the CrowdStrike Falcon API. Check credentials.")
inform("API Connected")

# Create our initial dataset and save our CISA vulnerabilities listing
dataframe = parse_cisa_data(retrieve_cisa_vulnerabilities(today_value=TODAY))
# Search for matches to these vulnerabilities within Spotlight and write the results
matched_dataframe = search_for_spotlight_matches(inbound_dataframe=dataframe,
                                                 today_value=TODAY,
                                                 hide_closed=FILTER_CLOSED
                                                 )
# Correlate and write the results
correlated_dataframe = correlate_results(inbound_dataframe=matched_dataframe, today_value=TODAY)
# Prioritize by asset count and write the results
prioritized_dataframe = prioritize_results(inbound_dataframe=correlated_dataframe, today_value=TODAY)
# Sort by severity and write the results
final_dataframe = sort_by_severity(inbound_dataframe=prioritized_dataframe, today_value=TODAY)
# Process finished
hint = [
    "For more prescriptive guidance, ",
    "leverage data within CrowdStrike's Falcon Spotlight ",
    "which can provide specific remediations for each asset"
]
print("".join(hint))
print("Process completed")
