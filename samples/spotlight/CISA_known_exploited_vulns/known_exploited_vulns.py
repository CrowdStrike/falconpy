"""DHS Known Vulnerabilities correlated with CrowdStrike Spotlight.

 _______             __   __ __       __    __
|   _   .-----.-----|  |_|  |__.-----|  |--|  |_
|   1___|  _  |  _  |   _|  |  |  _  |     |   _|
|____   |   __|_____|____|__|__|___  |__|__|____|
|:  1   |__|                   |_____|
|::.. . |
`-------'   DHS Known Vulnerabilities correlator

Creation date: 02.02.22 - ciberesponce@CrowdStrike, jshcodes@CrowdStrike

Based on the example:
https://github.com/CrowdStrike/falconpy/blob/main/samples/spotlight/find_hosts_by_cve.py

Requires: crowdstrike-falconpy v0.9.0+
          numpy
          pandas
          requests
"""
import sys
from datetime import date
from argparse import ArgumentParser, RawTextHelpFormatter
try:
    import requests
except ImportError as no_requests:
    raise SystemExit("The requests package must be installed in order to use this application.") from no_requests

try:
    import numpy as np
except ImportError as no_numpy:
    raise SystemExit("The numpy package must be installed in order to use this application.") from no_numpy

try:
    import pandas as pd
except ImportError as no_pandas:
    raise SystemExit("The pandas package must be installed in order to use this application.") from no_pandas

try:
    from falconpy import SpotlightVulnerabilities
except ImportError as no_falconpy:
    raise SystemExit("The crowdstrike-falconpy package must be installed "
                     "in order to use this application.") from no_falconpy

def inform(msg: str):
    """Provide informational updates to the user as the program progresses."""
    print("  %-80s" % msg, end="\r", flush=True)  # pylint: disable=C0209


def parse_command_line() -> object:
    """Parse any received inbound command line parameters."""
    inform("Retrieving configuration detail")
    parser = ArgumentParser(
        description=__doc__,
        formatter_class=RawTextHelpFormatter
        )
    parser.add_argument(
        '-k',
        '--client_id',
        help='CrowdStrike Falcon API key ID.\n'
        'You can also use the `FALCON_CLIENT_ID` environment variable to specify this value.',
        required=True
        )
    parser.add_argument(
        '-s',
        '--client_secret',
        help='CrowdStrike Falcon API key secret.\n'
        'You can also use the `FALCON_CLIENT_SECRET` environment variable to specify this value.',
        required=True
        )
    parser.add_argument(
        '-b',
        '--base_url',
        help='CrowdStrike API region (us1, us2, eu1, usgov1)'
        ' NOT required unless you are using `usgov1`.',
        required=False
    )
    parser.add_argument(
        '-v',
        '--ssl_verify',
        help='By default, we will validate HTTPS SSL verification when downloading DHS Known Exploited Vulnerabilties.\n'
        ' However if you are behind a network device that intercepts HTTPS connections, '
        'this could cause an error. Set this to false if you know this to be the case.',
        required=False
    )
    parser.add_argument(
        '-c',
        '--child',
        help='Child CID to retrieve results for.',
        required=False
    )

    return parser.parse_args()


def crowdstrike_spotlight_lookup(cves: list) -> list:
    """Look up CVE hits for matches within CrowdStrike Spotlight."""
    # force this to be a list
    if not isinstance(cves, list):
        cves = [cves]
    result = falcon.query_vulnerabilities(filter=f"cve.id:{cves}")
    if result["status_code"] >= 400:
        raise SystemExit(result["body"]["errors"][0]["message"])
    return result


def get_unique_host_ids(results_list: list) -> list:
    """Generate a list of unique host ID matches."""
    # first, scrub the list keeping only the host id from each resource result
    new_list = []
    for item in results_list:
        # grab first part of string, which is CrowdStrike host id
        new_list.append(item.partition("_")[0])
    # push into numpy so we can then use its _unique_ function as some machines can have multiple
    #   CPEs impacted by a single CVE (i.e. Edge and IE; these mappings to application can be done in Spotlight UI Console)
    return np.unique(np.array(new_list)).tolist()


def retrieve_constants(args: object):
    """Consume command line and environment variables and return constant values as specified."""
    # Set constants based upon received inputs
    base = "auto"
    ssl_verify = True
    member_cid = None
    if args.base_url:
        base = args.base_url
    if args.client_id:
        client_id = args.client_id
    if args.client_secret:
        client_secret = args.client_secret
    if args.ssl_verify:
        ssl_verify = args.ssl_verify
    if args.child:
        member_cid = args.child
    today = date.today().strftime("%Y-%m-%d")

    return base, client_id, client_secret, today, ssl_verify, member_cid


def retrieve_cisa_vulnerabilities(today_value: str) -> str:
    """Retrieve the CISA Known Exploited Vulnerabilities file."""
    inform("Retrieving CISA Known Exploited Vulnerabilities")
    # Get DHS CISA file
    cisa_csv_uri = 'https://www.cisa.gov/sites/default/files/csv/known_exploited_vulnerabilities.csv'
    created_file = f"{sys.path[0]}/{today_value}_CisaKnownExploitable.csv"
    if SSL_VERIFY == "False":
        cisa_csv_request = requests.get(cisa_csv_uri, verify=False)
    else:
        cisa_csv_request = requests.get(cisa_csv_uri, verify=True)

    if cisa_csv_request.status_code != 200:
        raise SystemExit(
            f"ERROR! Unable to download CISA's CSV file.\nCheck internet or see if site still exists at: {cisa_csv_uri}"
            )

    with open(created_file, 'wb') as known_exploitable:
        known_exploitable.write(cisa_csv_request.content)

    return created_file


def connect_api(client_id_value: str,
                client_secret_value: str,
                base_url_value: str,
                member_cid: str = None
                ) -> SpotlightVulnerabilities:
    """Connect to the CrowdStrike Spotlight API."""
    inform("Connecting API")
    return SpotlightVulnerabilities(client_id=client_id_value,
                                    client_secret=client_secret_value,
                                    base_url=base_url_value,
                                    member_cid=member_cid
                                    )


def search_for_spotlight_matches(inbound_dataframe, today_value):
    """Search the dataframe for results that have matches within Spotlight."""
    inform_msg = "Comparing DHS Known Exploited Vulns against Spotlight data--this could take a while"
    compare_count = 0
    compare_up = True
    inform(inform_msg)
    for i in range(0, len(inbound_dataframe)):
        cve_guid = inbound_dataframe.iloc[i]['cveID']
        spotlight_results = crowdstrike_spotlight_lookup(cve_guid)
        resources_results = spotlight_results['body']['resources']
        resources_list = []
        if len(resources_results) > 0:
            inform(f"{inform_msg} {'.' * compare_count}x")
            resources_list = get_unique_host_ids(resources_results)
        else:
            inform(f"{inform_msg} {'.' * compare_count}.")
        inbound_dataframe.at[i, 'AssetsVulnerable'] = resources_list
        inbound_dataframe.at[i, 'AssetsVulnerableCount'] = len(resources_list)
        if compare_count >= 10:
            compare_up = False
        if compare_up:
            compare_count += 1
        else:
            compare_count -= 1
        if compare_count == 0:
            compare_up = True

    inform("Writing RAW data")
    # todo - filter out all ones 0 as new dataframe
    inbound_dataframe.to_csv(f"{sys.path[0]}/{today_value}_RawDhsCve.csv", sep=",", na_rep="N/A")

    return inbound_dataframe


def parse_cisa_data(parse_file: str) -> object:
    """Parse the CISA Known Exploited Vulnerabilities file and create a new dataframe."""
    inform("Parsing results")
    # Now parse CSV using pandas, GUID is CVE-ID
    new_dataframe = pd.read_csv(parse_file, parse_dates=['dueDate', 'dateAdded'])

    # extend dataframe
    new_dataframe['AssetsVulnerableCount'] = int(0)
    pd.to_numeric(new_dataframe['AssetsVulnerableCount'])
    # force these fields to be dtype objects
    new_dataframe['AssetsVulnerable'] = pd.NaT
    new_dataframe['AssetsVulnerable'] = new_dataframe['AssetsVulnerable'].astype('object').dtypes

    return new_dataframe


def correlate_results(inbound_dataframe, today_value) -> object:
    """Remove uncorrelated results and sort by asset count, writing results to a file."""
    inform("Removing uncorrelated results")
    # remove ones who have no fusion with Spotlight data
    inbound_dataframe = inbound_dataframe[inbound_dataframe.AssetsVulnerableCount != 0]
    inform("Sorting by asset count")
    # sort by Count of Assets Vulnerable per CVE
    top_cves_by_count_df = inbound_dataframe.sort_values(by='AssetsVulnerableCount', ascending=False)
    top_cves_by_count_df.to_csv(f"{sys.path[0]}/{today_value}_TopDhsCves.csv", sep=",", na_rep="N/A")

    return inbound_dataframe


def prioritize_results(inbound_dataframe, today_value) -> object:
    """Prioritize results by due date and write to a CSV file."""
    inform("Prioritizing")
    # sort by due-date for prioritization to be compliance against DHS
    inbound_dataframe = inbound_dataframe.sort_values(by='dueDate')
    inform("Writing prioritized results--based on DueDate per DHS CISA")
    inbound_dataframe.to_csv(f"{sys.path[0]}/{today_value}_MostUrgentUnpatchedDhsCves.csv", sep=",", na_rep="N/A")

    return inbound_dataframe


def sort_by_severity(inbound_dataframe, today_value) -> object:
    """Sort results by severity and write to a CSV file."""
    inform("Sorting by severity")
    handled = pd.Series(inbound_dataframe['AssetsVulnerable'].explode().unique())
    inform("Writing prioritized results--based on number of unique impacted assets")
    handled.to_csv(f"{sys.path[0]}/{today_value}_MostVulnerableAssetsDhsCves.csv", sep=",", na_rep="N/A")

    return handled


# Retrieve all inbound command line parameters
TODAY = date.today().strftime("%Y-%m-%d")
BASE_URL, CLIENT_ID, CLIENT_SECRET, TODAY, SSL_VERIFY, MEMBER_CID = retrieve_constants(parse_command_line())

# Connect to the CrowdStrike Spotlight API
falcon = connect_api(CLIENT_ID, CLIENT_SECRET, BASE_URL, MEMBER_CID)
if falcon.token_status != 201:
    # Unsuccessful API login, exit routine.
    raise SystemExit("Unable to access the CrowdStrike Falcon API. Check credentials.")
inform("API Connected")

# Create our initial dataset and save our CISA vulnerabilities listing
dataframe = parse_cisa_data(retrieve_cisa_vulnerabilities(today_value=TODAY))
# Search for matches to these vulnerabilities within Spotlight and write the results
matched_dataframe = search_for_spotlight_matches(inbound_dataframe=dataframe, today_value=TODAY)
# Correlate and write the results
correlated_dataframe = correlate_results(inbound_dataframe=matched_dataframe, today_value=TODAY)
# Prioritize by asset count and write the results
prioritized_dataframe = prioritize_results(inbound_dataframe=correlated_dataframe, today_value=TODAY)
# Sort by severity and write the results
final_dataframe = sort_by_severity(inbound_dataframe=prioritized_dataframe, today_value=TODAY)
# Process finished
hint = [
    "For more prescriptive guidance, ",
    "leverage data within CrowdStrike's Falcon Spotlight ",
    "which can provide specific applications within each asset"
]
print("".join(hint))
print("Process completed")
